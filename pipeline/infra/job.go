package main

import (
	"fmt"
	"strings"
)

// JobResult represents the result of a Continuous Integration (CI) action.
// It contains information about the unit that was executed, the output of the action,
// and any error that may have occurred during execution.
type JobResult struct {
	WorkDir string // WorkDir indicates the specific unit of work that was executed.
	Output  string // Output contains the result or output generated by the action.
	Err     error  // Err holds any error encountered during the execution of the action.
}

// processActionResults collects results from concurrent actions executed in a separate goroutine.
// It aggregates any errors encountered during the execution and formats a success report.
// The function takes a channel of ActionResult, which contains the results of the actions,
// and returns a formatted string report of successful actions or an error if any occurred.
//
// Parameters:
//   - resultChan: A channel of ActionResult that receives results from concurrent actions.
//
// Returns:
//   - A string containing a summary of all successful actions and their outputs, or an empty string
//     if there were errors.
//   - An error that aggregates all encountered errors, or nil if no errors occurred.
func processActionAsyncResults(resultChan chan JobResult) (string, error) {
	// collectors for errors and successful results
	var collectedActionErrors []error
	var successfulResults []JobResult

	// Iterate over results received from the channel
	for result := range resultChan {
		if result.Err != nil {
			// Collect any errors encountered
			collectedActionErrors = append(collectedActionErrors, result.Err)
		} else {
			// Store successful results
			successfulResults = append(successfulResults, result)
		}
	}

	return formatResultsReport(collectedActionErrors, successfulResults)
}

// ProcessActionSyncResults collects results from a slice of synchronously executed actions.
// It aggregates any errors encountered during the execution and formats a success report
// by calling the internal formatResultsReport helper function.
// It takes a slice of ActionResult and returns a formatted string report or a joined error.
func ProcessActionSyncResults(results []JobResult) (string, error) {
	// collectors
	var collectedActionErrors []error
	var successfulResults []JobResult // Collect successful results in order

	// Separate errors and successes from the input slice
	for _, result := range results {
		if result.Err != nil {
			collectedActionErrors = append(collectedActionErrors, result.Err)
		} else {
			successfulResults = append(successfulResults, result)
		}
	}

	// Delegate processing and formatting to the helper function
	return formatResultsReport(collectedActionErrors, successfulResults)
}

// formatResultsReport takes collected errors and successful results, aggregates errors,
// and formats a success report. This is the core reusable logic.
func formatResultsReport(collectedActionErrors []error, successfulResults []JobResult) (string, error) {
	// Handling errors first.
	if len(collectedActionErrors) > 0 {
		// Use JoinErrors from err.go (assuming it's in the same package or imported)
		return "", JoinErrors(collectedActionErrors...)
	}

	// Handling, and showing outputs
	var outputBuilder strings.Builder
	outputBuilder.WriteString("All actions passed successfully.\n\nOutput:\n") // Simplified success message
	outputBuilder.WriteString("=====================\n")

	// Display successful outputs in the order they were collected
	if len(successfulResults) == 0 {
		outputBuilder.WriteString("(No successful actions with output)\n")
	} else {
		for _, result := range successfulResults {
			// Use the existing String() method or format directly
			outputBuilder.WriteString(result.String()) // Assumes ActionResult has a useful String() method
			// Ensure a newline after each result's output if not already present by String()
			if !strings.HasSuffix(result.String(), "\n") {
				outputBuilder.WriteString("\n")
			}
			outputBuilder.WriteString("--------------------\n") // Separator
		}
	}

	return outputBuilder.String(), nil // Return combined stdout and nil error
}

// String returns a formatted string representation of the ActionResult.
// It includes the working directory, the command executed, and any output or error messages.
// If there is an error associated with the ActionResult, it will be included in the output.
// If there is no output, a default message indicating that is returned.
//
// The format of the returned string is as follows:
//   - If there is an error: "WorkDir [<WorkDir>]: Error - <ErrorMessage>"
//   - If there is no error and output is present:
//     "--- WorkDir: <ExecutionPath> ---\nCommand: <CommandName>\n<Output>"
//   - If there is no error and no output:
//     "--- WorkDir: <ExecutionPath> ---\nCommand: <CommandName>\n(No standard output)"
func (ar JobResult) String() string {
	if ar.Err != nil {
		return fmt.Sprintf("WorkDir [%s]: Error - %v", ar.WorkDir, ar.Err)
	}

	output := "(No standard output)"

	if ar.Output != "" {
		output = ar.Output
	}

	// Format clearly indicating the unit and command (extracted from Unit key)
	parts := strings.Split(ar.WorkDir, ".")
	tgExecutionPath := ar.WorkDir
	commandName := ""

	if len(parts) == 2 {
		tgExecutionPath = parts[0]
		commandName = parts[1]
	}

	return fmt.Sprintf("--- WorkDir: %s ---\nCommand: %s\n%s", tgExecutionPath, commandName, output)
}
